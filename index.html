<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 <script src="https://cjrtnc.leaningtech.com/2.3/loader.js"></script>
 <script>cheerpjInit({enablePreciseAppletArchives:true});</script>
 <script src=kb.js></script>
 <script>kb(19, 100, 1200)</script>
 <script src=rtwr.js></script>
 <script>rt(19,500,120)</script>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
<title>The Easiest Method for Beginners</title>
</head>
<body>
<table style="text-align: left; width: 100%;" border="0" cellpadding="4" cellspacing="8">
  <tbody>
    <tr style="font-weight: bold;">
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><big>The
Easiest<small><small><sup style="font-weight: normal;">(*)</sup></small></small>
Method for Beginners<br>
      <small><small><small><small><small><sup style="font-weight: normal;">(*)</sup><span style="font-weight: normal;"> Or maybe the worst...</span></small></small></small></small></small><br>
      </big></big></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
It's
perfectly possible to solve a Rubik's Cube using common intuition and
simple rules.<br>
Usually, people can solve one layer by themselves. If you can do it,
you
(almost) can solve the whole cube.<br>
      <br>
No mysterious magical sequences required. If you understand how it
works, you'll remember it forever.<br>
No need to learn any notation, the animated cubes will show you the
basic moves you need.<br>
No mathematical formulae (group theory principles explained <a href="https://web.archive.org/web/20041208083322/http://www.geocities.com/jaapsch/puzzles/">here</a>), I'll try
to make it intuitive.<br>
      <br>
This page is not about efficient solving.<br>
      <br>
If you think this page is not very helpful, you should take a look at <a href="https://web.archive.org/web/20041208083322/http://www.geocities.com/jasmine_ellen/RubiksCubeSolution.html">Jasmine's
beginner page</a> where a more conventional approach is proposed.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><span style="font-weight: bold;">Solving the first layer</span></big></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
It
seems that everybody can do it using common intuition. It can take some
time if it's your first try.<br>
You cube should now look like this:<br>
      <div style="text-align: center;"><br>
      <applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="colorTable" value="0x003373,0xff4600,0xf8f8f8,0x00732f,0x8c000f, 0xffd200,0x707070">
      <param name="stickers" value="0,0,0,6,6,6,6,6,6,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,3,3,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5"></applet>
      <br>
      <br>
      </div>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big style="font-weight: bold;">Manipulating the first layer</big></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
You
just built a layer starting from a random state. So, you should not
have
any problem making transformations of this layer.<br>
Look at the following basic moves. You can do them differently, it
doesn't matter.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="colorTable" value="0x003373,0xff4600,0xf8f8f8,0x00732f,0x8c000f, 0xffd200,0x707070"><param name="stickers" value="0,0,0,6,6,6,6,6,6,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,3,3,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5"><param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="R'DRFDF'"></applet><br>
Rotate a corner<br>
            </td>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="colorTable" value="0x003373,0xff4600,0xf8f8f8,0x00732f,0x8c000f, 0xffd200,0x707070"><param name="stickers" value="0,0,0,6,6,6,6,6,6,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,3,3,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5"><param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="FEF2E2F"></applet><br>
Rotate an edge</td>
          </tr>
          <tr>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="colorTable" value="0x003373,0xff4600,0xf8f8f8,0x00732f,0x8c000f, 0xffd200,0x707070"><param name="stickers" value="0,0,0,6,6,6,6,6,6,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,3,3,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5"><param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="LU'RD2R'UL'"></applet><br>
Swap two corners</td>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="colorTable" value="0x003373,0xff4600,0xf8f8f8,0x00732f,0x8c000f, 0xffd200,0x707070"><param name="stickers" value="0,0,0,6,6,6,6,6,6,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,3,3,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5"><param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="MSDS'D2'M'"></applet><br>
Swap two edges</td>
          </tr>
        </tbody>
      </table>
      <br>
Do you have problems understanding them? Don't go to the next section
before you can master these easy moves (or the ones you found) allowing
you to change pieces of the first layer easily.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><span style="font-weight: bold;">Rearranging the first layer without
disturbing the others</span></big></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
Once
a first layer is solved, freedom of movement is reduced, and people
can't
see what they can do without destroying it. You have to find a way of
moving only selected cubies, preserving the
state of others (local transformation).<br>
      <br>
Take the first basic move that rotates a corner for example. What's
the problem with it? It destroys the two lower layers of course. Do it
backwards, the cube is restored.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptProgress" value="0"> <param name="script" value="R'DRFDF'"></applet><br>
Doing a move</td>
            <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(R'DRFDF')'"></applet><br>
Undoing a move</td>
          </tr>
        </tbody>
      </table>
      <br>
But what happened at the end of the move? Think of it this way:<br>
- Pieces of the first layer have been rearranged.<br>
- Pieces of the two lower layers have been rearranged.<br>
- Pieces of the first layer and pieces of the two lower layers are
still separated.<br>
- Undoing the move will independently restore the state of the first
layer and the state of the two lower layers.<br>
      <br>
And now, the cornerstone of this method. Try this:<br>
      <span style="font-weight: bold;">- Do a move that rearranges
pieces of the first layer. Call it X.</span><br style="font-weight: bold;">
      <span style="font-weight: bold;">- Move the first layer. Call it
Y.</span><br style="font-weight: bold;">
      <span style="font-weight: bold;">- Undo X. Call it X'.</span><br style="font-weight: bold;">
      <span style="font-weight: bold;">- Undo Y (</span><span style="font-weight: bold;"><span style="font-weight: bold;">only a
matter of&nbsp; readjusting the first layer)</span></span><span style="font-weight: bold;">. Call it Y'.</span><br>
      <br>
Since the two lower layers and their chaos have not been changed by Y,
X' can still restore them to their original state!<br>
But the first layer has moved, it won't be restored with X'. The
backward transformation will be applied to a different part of it.<br>
      <br>
We have reached our goal: Making (local) transformations in a layer,
without disturbing the others.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: middle;"><span style="text-decoration: underline;">Example</span>:<br>
- X is a clockwise corner rotation move.<br>
- Y is a clockwise turn of the first layer.<br>
- X' is a counter-clockwise corner rotation move.<br>
- Y' is a counter-clockwise turn.<br>
Result: Two corners in the first layer have been rotated (different
directions).</td>
            <td style="vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptProgress" value="0"> <param name="script" value="(R'DRFDF')U(R'DRFDF')'U'"></applet><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
Thanks to the four basic moves, we can build four interesting local
transformations of the first layer.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="4">
        <tbody>
          <tr>
            <td style="vertical-align: middle; background-color: rgb(255, 255, 255);"><span style="font-weight: bold;">Basic move (X)</span><br>
            </td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;"><span style="font-weight: bold;">Result of the commutator (X.Y.X'.Y')</span><br>
            </td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle; text-align: center;"><span style="font-weight: bold;">Example</span><br>
            </td>
          </tr>
          <tr>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Rotate
a corner</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Rotate
two corners</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="150" width="150"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(R'DRFDF')U(R'DRFDF')'U'"></applet><br>
            </td>
          </tr>
          <tr>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Rotate
an edge</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Rotate
two edges</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="150" width="150"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(FEF2E2F)U(FEF2E2F)'U'"></applet><br>
            </td>
          </tr>
          <tr>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Swap
two corners</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Swap
three corners</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="150" width="150"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(LU'RD2R'UL')U(LU'RD2R'UL')'U'"></applet><br>
            </td>
          </tr>
          <tr>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Swap
two edges</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle;">Swap
three edges</td>
            <td style="background-color: rgb(255, 255, 255); vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="150" width="150"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(MSDS'D2M')U(MSDS'D2M')'U'"></applet><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><span style="font-weight: bold;">Changing pieces belonging to different
layers</span></big></big></td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
The
pieces on which a local transformation must be applied do not
always belong to the same layer. You'll have to bring them to a same
layer first with a positioning move:<br>
- Make interesting pieces belong to the first layer. Call it P.<br>
- X.Y.X'.Y'.<br>
- Undo the positioning move. Call it P'.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: middle;"><span style="text-decoration: underline;">Example</span>: Permutation of
three
edges.<br>
- Move the front side and then the right side to bring edges to
up-front and up-right (P).<br>
- Apply the three-edge swapping technique (based on X.Y.X'.Y').<br>
- Move the right side and then the front side back to their original
positions (P').</td>
            <td style="vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(F2R')(MSDS'D2'M')U(MSDS'D2'M')'U'(F2R')'"></applet><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
That's all you need to solve the 3x3x3 cube.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><span style="font-weight: bold;">Solving example on a random cube</span></big></big><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);">
      <table style="width: 100%; text-align: left;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: middle;">Let's solve a cube
completely.<br>
I don't detail how the first layer is built, you can do it, even if it
takes more moves.<br>
            <br>
One by one, the edges of the second layer are positioned, using
exclusively sequences that swap three edges. Red-green edge is easy,
because in the same layer, you can find its destination and another
free edge position.
Same thing for red-blue and green-orange. It's more difficult for the
blue-orange edge. A positioning move brings blue-orange, it's
destination position, and another free position to the same layer. This
move is undone at the end of the sequence.<br>
            <br>
Now, the last layer. You'll notice that only the blue-white-red corner
is at a correct place, the three others must be swapped. Then, three
edges are swapped, because the white-red edge only is where it needs to
be. Finally, we have to fix the orientations.<br>
            </td>
            <td style="vertical-align: middle;">&nbsp;<applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="400" width="350"><param name="beta" value="30"><param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="10"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="[solve a layer] DR2BR'DBEBL2D'BDB'F'D'FU2\n
[red-green] y2z' (MSDS'D2'M') U (MSDS'D2'M')' U'\n
[red-blue] x2 (MSDS'D2'M') U (MSDS'D2'M')' U'\n
[green-orange] x' (MSDS'D2'M') U (MSDS'D2'M')' U'\n
[blue-orange] b (MSDS'D2'M') U (MSDS'D2'M')' U' b'\n
[swap 3 corners] z'y' (LU'RD2R'UL') U' (LU'RD2R'UL')' U\n
[swap 3 edges] (MSDS'D2'M') U' (MSDS'D2'M')' U\n
[rotate 2 corners] (R'DRFDF') U2 (R'DRFDF')' U2\n
[rotate 2 edges] y (FEF2E2F) U (FEF2E2F)' U' z2"><br>
            </applet><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(204, 204, 204);"><big><big><span style="font-weight: bold;">Improvements</span></big></big><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; background-color: rgb(240, 240, 240);"><br>
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; background-color: rgb(255, 255, 255);"><big><big><span style="font-weight: bold;">Working with slices</span></big></big><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><br>
All the examples above were based on working with a side of the cube.
You can apply the same rules to inner slices as well.<br>
X must be a move that rearranges pieces of a slice, and Y a move of
this slice.<br>
            <br>
            <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
              <tbody>
                <tr>
                  <td style="vertical-align: middle;"><span style="text-decoration: underline;">Example</span>: Permutation of
three edges in a slice.<br>
- Swap up-front and up-back edges (X).<br>
- Move center slice (Y).<br>
- Swap up-front and up-back edges again (X'=X).<br>
- Move center slice back (Y').<br>
                  </td>
                  <td style="vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="U2M'U2M"></applet><br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
            </td>
          </tr>
          <tr>
            <td style="background-color: rgb(255, 255, 255); vertical-align: top;"><big><big><span style="font-weight: bold;">Different kinds of pieces</span></big></big><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><br>
            <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
              <tbody>
                <tr>
                  <td style="vertical-align: middle;">For now, we've
only worked with corners or edges, but never both kinds of pieces at
the same moment. Why not? It's exactly the same principle. On the
example, two corner-edge blocks are removed from the first layer and
swapped.<br>
                  </td>
                  <td style="vertical-align: middle; text-align: center;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(LU'Rd2R'UL')U(LU'Rd2R'UL')'U'"></applet><br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; background-color: rgb(255, 255, 255);"><big><big><span style="font-weight: bold;">More interesting commutators</span></big></big><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;"><br>
In order to make things clear for beginners, I described a technique
based on changing things in a single layer. But commutators can be much
more powerful.<br>
Try to see how and why they work. Hint: The Y move doesn't compromise
any pieces but the ones we need to move.<br>
            <br>
            <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
              <tbody>
                <tr>
                  <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(U'R'U)L(U'R'U)'L'"></applet><br>
Swap three corners<br>
                  </td>
                  <td style="height: 50%; width: 50%; text-align: center; vertical-align: middle;"><applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="200" width="200"> <param name="beta" value="30"> <param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="0"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="(FR'F')M'(FR'F')'M"></applet><br>
Swap three edges<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
            </td>
          </tr>
          <tr style="font-weight: bold;">
            <td style="vertical-align: top; background-color: rgb(255, 255, 255);"><big><big>Same
random cube, but optimized solving</big></big></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">
            <table style="width: 100%; text-align: left;" border="0" cellpadding="2" cellspacing="2">
              <tbody>
                <tr>
                  <td style="vertical-align: middle;">Now we'll make
use of some improvements.<br>
                  <br>
Green-orange and green-red edges can be solved simulaneously with a
commutator based on a slice, after an easy positioning.<br>
Then I decided to swap three corners in an efficient way.<br>
Two edges again: Green-white and blue-orange.<br>
Then, the three last edges at a wrong place are moved.<br>
In the end, two misoriented edges are fixed.<br>
                  <br>
Once the first layered is completed, everything is based on an
identical strategy: P.X.Y.X'.Y'.P'.<br>
                  </td>
                  <td style="vertical-align: middle;">&nbsp;<applet code="ch.randelshofer.rubik.RubikPlayerApp.class" archive="/web/20041208083322oe_/http://grrroux.free.fr/begin/rubikplayer.zip" height="400" width="350"><param name="beta" value="30"><param name="backgroundColor" value="0xFFFFFF"> <param name="displayLines" value="7"> <param name="scriptLanguage" value="HarrisENG"> <param name="scriptType" value="Solver"> <param name="script" value="[solve a layer] DR2BR'DBEBL2D'BDB'F'D'FU2\n
[green-orange+green-red] z'x2 D2 U2 M' U2' M D2'\n
[corners] z'y' B (B'RB) L' (B'RB)' L B'\n
[green-white+blue-orange] (BL2D') U2 M U2' M' (BL2D')'\n
[position last edges] y2 d' (R'ER) U' (R'ER)' U d\n
[final orientation] R (R'E'R2E2R') U2 (R'E'R2E2R')' U2 R' z2"><br>
                  </applet><br>
                  </td>
                </tr>
              </tbody>
            </table>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<div style="text-align: center;"><big><a href="http://grrroux.free.fr/index.html">Return to
home</a></big><br>
</div>
</body>
</html>